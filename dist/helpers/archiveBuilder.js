"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _archiver = _interopRequireDefault(require("archiver"));

var _path = _interopRequireDefault(require("path"));

var _winston = _interopRequireDefault(require("winston"));

var _fileHelpers = require("./fileHelpers.js");

var _certificateBuilder = require("./certificateBuilder.js");

var _winstonConfig = require("../modules/winston.config.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(function () {
  var enterModule = require('react-hot-loader').enterModule;

  enterModule && enterModule(module);
})();

var EJSON = require('mongodb-extjson');

var logger = _winston.default.createLogger({
  transports: [new _winston.default.transports.Console({
    level: process.env.PROVENDOCS_LOG_LEVEL || 'debug',
    json: true,
    colorize: true,
    format: _winstonConfig.certificateAPIFormat
  })]
});
/**
 * Simple helper function for constructing the contents of the Archive ReadMe File
 * @ TODO -> In future it would be great to use something like Handlebars for this instead.
 * @param {*} fileInformation  - The file document from MongoDB.
 * @param {*} userInformation - Information about the user profile.
 * @param {*} proofInformation - The documentProof for the file.
 * @param {*} versionProof - The versionProof for the file.
 * @returns {string} - A string containing the contents of the ReadMe file.
 */


var getReadMeString = function getReadMeString(fileInformation, userInformation, proofInformation, versionProof) {
  var name = fileInformation.name,
      uploadedAt = fileInformation.uploadedAt;
  var email = userInformation.email;
  var btcBlockNumber = proofInformation.btcBlockNumber,
      btcTransaction = proofInformation.btcTransaction;
  var submitted = versionProof.submitted;
  var proofHash = versionProof.hash;
  var hash = fileInformation._provendb_metadata.hash;
  var url = 'PLACEHOLDER_URL';
  var cliDownload = 'http://provendocs.com/downloads/validateHash';
  var verifyCommands = 'PLACEHOLDER_VERIFY_COMMANDS';
  return "Summary\n-------\nThis archive ".concat(name, ".proof.zip contains a blockchain proof\nfor the document ").concat(name, ".\n").concat(name, " was uploaded to ProvenDocs on ").concat(uploadedAt, " by ").concat(email, "\nand proved to the Bitcoin blockchain  at ").concat(submitted, ". \nThe bitcoin blockchain proof details are:\n*  Bitcoin block ").concat(btcBlockNumber, "\n*  Bitcoin transaction ID ").concat(btcTransaction, "\n*  Document hash ").concat(hash, "\n*  ProvenDocs proof hash ").concat(proofHash, "\n\nContents\n--------\nThis archive contains the following files:\n    ").concat(name, " is the file which was uploaded\n    ").concat(name, ".json is the file which was uploaded in JSON format\n    ").concat(name, ".proof.binary is the Chainpoint format blockchain proof in binary format\n    ").concat(name, ".proof.json is the Chainpoint format blockchain proof in JSON format\n    ").concat(name, ".proof.pdf is a PDF document summarizing the document proof\n\nViewing and validating the document proof\n-----------------------------------------\nYou can view this document and it's proof (subject to permissions)\nat https://provendocs.com/").concat(url, ".\nYou can validate this archive - confirming the integrity of the document\nand validity of the proof - using our open using our open source command\nline tool.\nDownload the tool from ").concat(cliDownload, ".\n\nTo independently validate this document proof:\n1. Recaculate the document hash using our open source command line tool.\n    The following command line will calculate the hash:\n    provendb-verify ").concat(verifyCommands, "\n2.  Compare the hash in the ").concat(name, ".proof.json with that generated by\n    the command line tool.  If the hashes match, then the chainpoint\n    proof is valid for that document.\n3.  Validate the ").concat(name, ".proof.json document using the toolset\n    providing by the chainpoint project.  See http://chainpoint.org\n    and https://github.com/chainpoint\n\nFind out more\n-------------\nSee http://provendocs.com/faq for more details about how these proofs\nwork.   \n");
};
/**
 * Creates an archive from the retrieved information including:
 * - The File.
 * - The File Information in JSON format.
 * - The Proof in JSON format.
 * - The Proof in Binary Format.
 * - The Proof certificate.
 * - A ReadMe file explaining the archive.
 * @param {Object} fileInformation - The file document from MongoDB.
 * @param {*} proofInformation - The VersionProof for the document.
 * @param {*} documentProof - The documentProof for the document.
 * @param {*} user - Information about the user profile.
 * @returns {string} The path to the archive for uploading to user.
 */


var createArchiveForDocument = function createArchiveForDocument(fileInformation, proofInformation, documentProof, user) {
  return new Promise(function (resolve, reject) {
    logger.log({
      level: 'info',
      message: 'Creating archive...'
    });
    logger.log({
      level: 'debug',
      message: 'Archive Info: ',
      fileName: fileInformation.name,
      user: user,
      proofInformation: proofInformation,
      documentProof: documentProof
    }); // Create Archive.

    var path = _path.default.join(__dirname, "archives/".concat(fileInformation.name, ".proof.zip"));

    var output = _fs.default.createWriteStream(path);

    var archive = (0, _archiver.default)('zip', {
      zlib: {
        level: 9
      } // Sets the compression level.

    }); // Triggered on finish.

    output.on('close', function () {
      logger.log({
        level: 'info',
        message: 'Done writing to archive',
        totalBytes: archive.pointer()
      });
      resolve(path);
    }); // Anytime a source is drained.

    output.on('end', function () {
      logger.log({
        level: 'debug',
        message: 'Data has been drained.'
      });
    }); // Catch non-blocking warnings.

    archive.on('warning', function (err) {
      if (err.code === 'ENOENT') {
        logger.log({
          level: 'error',
          message: 'Error during archive process',
          err: err
        });
      } else {
        logger.log({
          level: 'error',
          message: 'Fatal error during archive process',
          err: err
        });
        reject(err);
      }
    }); // Catch blocking errors

    archive.on('error', function (err) {
      logger.log({
        level: 'error',
        message: 'Fatal error during archive process',
        err: err
      });
      reject(err);
    }); // Pipe archive data to the file

    archive.pipe(output);
    (0, _fileHelpers.decodeFile)(fileInformation).then(function (filePath) {
      logger.log({
        level: 'debug',
        message: 'Adding file...',
        filePath: filePath
      });
      archive.file(filePath, {
        name: "".concat(fileInformation.name)
      });
      logger.log({
        level: 'debug',
        message: 'Adding Certificate..'
      });
      (0, _certificateBuilder.createPDF)({
        proofs: [proofInformation]
      }, {
        proofs: [documentProof]
      }, fileInformation, user).then(function (certPath) {
        logger.log({
          level: 'debug',
          message: 'Success, Generated Certificate for file:',
          certPath: certPath,
          fileName: fileInformation.name,
          user: user
        }); // Add the Proof Certificate file to the Archive.

        archive.file(certPath, {
          name: "".concat(fileInformation.name, ".proof.pdf")
        }); // Add the README.txt to the archive.

        logger.log({
          level: 'debug',
          message: 'Appending README...'
        });
        archive.append(getReadMeString(fileInformation, user, documentProof, proofInformation), {
          name: 'README.txt'
        }); // Add the JSON version of the file to archive:

        logger.log({
          level: 'debug',
          message: 'Adding JSON version of doc + metadata...'
        });
        archive.append(EJSON.stringify(fileInformation, null, 2), {
          name: "".concat(fileInformation.name, ".doc.json")
        }); // Add the Chainpoint blockchain proof in binary format.

        logger.log({
          level: 'debug',
          message: 'Adding Chainpoint Proof (binary)...'
        });
        var binaryString = JSON.stringify(documentProof.proof);
        archive.append(binaryString.slice(1, -1), {
          name: "".concat(fileInformation.name, ".proof.binary")
        }); // Add the Chainpoint proof in JSON format.

        logger.log({
          level: 'info',
          message: 'Adding Chainpoint Proof (JSON)',
          documentProof: documentProof
        });
        archive.append(JSON.stringify(documentProof.proof), {
          name: "".concat(fileInformation.name, ".proof.json")
        }); // Finalize the archive.

        logger.log({
          level: 'debug',
          message: 'Finalizing Archive...'
        });
        archive.finalize();
      }).catch(function (createCertErr) {
        var returnObject = {
          level: 'error',
          message: 'Failed to create PDF Proof Certificate for Archive',
          createCertErr: createCertErr,
          fileName: fileInformation.name,
          proofInformation: proofInformation,
          documentProof: documentProof
        };
        logger.log(returnObject);
        reject(returnObject);
      });
    }).catch(function (decodeFileErr) {
      reject(decodeFileErr);
    });
  });
};

var _default = createArchiveForDocument;
var _default2 = _default;
exports.default = _default2;
;

(function () {
  var reactHotLoader = require('react-hot-loader').default;

  var leaveModule = require('react-hot-loader').leaveModule;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(logger, "logger", "/Users/mike/SouthbankSoftware/provendb/provendocs/src/server/helpers/archiveBuilder.js");
  reactHotLoader.register(getReadMeString, "getReadMeString", "/Users/mike/SouthbankSoftware/provendb/provendocs/src/server/helpers/archiveBuilder.js");
  reactHotLoader.register(createArchiveForDocument, "createArchiveForDocument", "/Users/mike/SouthbankSoftware/provendb/provendocs/src/server/helpers/archiveBuilder.js");
  reactHotLoader.register(_default, "default", "/Users/mike/SouthbankSoftware/provendb/provendocs/src/server/helpers/archiveBuilder.js");
  leaveModule(module);
})();

;